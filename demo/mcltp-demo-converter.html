<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Choir Voice Parts Manager</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
        }
        .song-title-container {
            margin: 20px 0;
            text-align: center;
        }
        .song-title-label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .song-title-input {
            width: 80%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        .bitrate-container {
            margin: 20px 0;
            text-align: center;
        }
        .bitrate-label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .bitrate-input {
            width: 80px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            text-align: right;
        }
        .drop-zone {
            border: 2px dashed #3498db;
            border-radius: 5px;
            padding: 25px;
            text-align: center;
            margin: 20px 0;
            background-color: #f8f9fa;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .drop-zone:hover {
            background-color: #e9ecef;
        }
        .drop-zone.active {
            background-color: #e3f2fd;
            border-color: #2196f3;
        }
        .voice-parts {
            list-style-type: none;
            padding: 0;
        }
        .voice-part {
            display: flex;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: move;
        }
        .voice-part.dragging {
            opacity: 0.5;
        }
        .handle {
            margin-right: 10px;
            color: #6c757d;
            cursor: grab;
        }
        .part-name {
            flex-grow: 1;
            margin-right: 10px;
            padding: 5px;
            border: 1px solid transparent;
            border-radius: 3px;
        }
        .part-name:focus {
            border-color: #80bdff;
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
        }
        .file-info {
            color: #6c757d;
            font-size: 0.8em;
            margin-right: 10px;
        }
        .delete-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .delete-btn:hover {
            background: #c82333;
        }
        .buttons {
            margin-top: 20px;
            text-align: center;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        .output {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            white-space: pre-wrap;
            word-break: break-all;
            display: none;
        }
        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: white;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <h1>Choir Voice Parts Manager</h1>
    
    <div class="song-title-container">
        <label class="song-title-label" for="songTitle">Song Title:</label>
        <input type="text" id="songTitle" class="song-title-input" placeholder="Enter choir recording title" value="Choir Recording">
    </div>

    <div class="bitrate-container">
        <label class="bitrate-label" for="bitratePerPart">Average encoding bitrate per part (kbps):</label>
        <input type="number" id="bitratePerPart" class="bitrate-input" value="48" min="16" max="512">
    </div>
    
    <div class="drop-zone" id="dropZone">
        <p>Drag and drop voice part files here or click to browse</p>
        <input type="file" id="fileInput" multiple style="display: none">
    </div>
    
    <ul class="voice-parts" id="voicePartsList"></ul>
    
    <div class="buttons">
        <button id="convertButton">Generate FFmpeg Command</button>
    </div>
    
    <div class="output" id="output"></div>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div id="loadingText">Loading FFmpeg...</div>
    </div>

    <script src="mcltp.ffmpeg-lgpl.js"></script>
    <script>
        // Runtime capability checks
        const checks = {
            webWorkers: 'Worker' in window,
            crossOriginIsolated: window.crossOriginIsolated === true,
            simd: WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])),
            sharedMemory: (() => {
                try {
                    new SharedArrayBuffer(1);
                    return true;
                } catch (e) {
                    return false;
                }
            })()
        };

        if (!Object.values(checks).every(v => v)) {
            const missing = Object.entries(checks)
                .filter(([_, v]) => !v)
                .map(([k]) => k)
                .join(', ');
            
            const message = `Missing required features: ${missing}\n\nThis application requires:\n- Web Workers\n- Cross-Origin Isolation\n- Fixed-Width SIMD support\n- Shared Memory support`;
            alert(message);
            throw new Error(message);
        }

        // Initialize FFmpeg
        let ffmpeg;
        
        async function initFFmpeg(loadingText) {
            
            ffmpeg = await createFFmpeg({
                logger: message => console.log('FFmpeg:', message),
                progress: p => {
                    console.log('FFmpeg progress:', p);
                    loadingText.textContent = `Processing: ${(p.ratio * 100).toFixed(0)}%`;
                },
                printErr: message => {
                    console.error('FFmpeg error:', message);
                    if (loadingOverlay.style.display === 'flex') {
                        loadingText.textContent = 'FFmpeg error: ' + message;
                    }
                }
            });
            return ffmpeg;
        }

        document.addEventListener('DOMContentLoaded', async function() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            const loadingText = document.getElementById('loadingText');
            loadingOverlay.style.display = 'flex';

            try {
                await initFFmpeg(loadingText);
                loadingText.textContent = 'FFmpeg initialized successfully';
                loadingOverlay.style.display = 'none';
            } catch (error) {
                console.error('FFmpeg initialization error:', error);
                loadingText.textContent = 'Failed to initialize FFmpeg: ' + error.message;
                return;
            }

            // Add global error handler for worker
            window.addEventListener('unhandledrejection', function(event) {
                console.error('Unhandled promise rejection:', event.reason);
                loadingText.textContent = 'Error: ' + event.reason;
                loadingOverlay.style.display = 'none';
            });

            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('fileInput');
            const voicePartsList = document.getElementById('voicePartsList');
            const convertButton = document.getElementById('convertButton');
            const output = document.getElementById('output');
            const songTitleInput = document.getElementById('songTitle');
            const bitratePerPartInput = document.getElementById('bitratePerPart');
            
            // Voice parts storage
            let voiceParts = [];
            
            // Handle file selection
            function handleFiles(files) {
                for (const file of files) {
                    if (file.type.startsWith('audio/')) {
                        const fileName = file.name;
                        const nameWithoutExtension = fileName.substring(0, fileName.lastIndexOf('.')) || fileName;
                        
                        voiceParts.push({
                            file: file,
                            name: nameWithoutExtension,
                            originalName: fileName
                        });
                    }
                }
                updateVoicePartsList();
            }
            
            // Update the list of voice parts in the UI
            function updateVoicePartsList() {
                voicePartsList.innerHTML = '';
                
                voiceParts.forEach((part, index) => {
                    const listItem = document.createElement('li');
                    listItem.className = 'voice-part';
                    listItem.dataset.index = index;
                    listItem.draggable = true;
                    
                    const handle = document.createElement('div');
                    handle.className = 'handle';
                    handle.innerHTML = '&#8942; &#8942;';
                    
                    const nameInput = document.createElement('div');
                    nameInput.className = 'part-name';
                    nameInput.textContent = part.name;
                    nameInput.contentEditable = true;
                    nameInput.addEventListener('blur', function() {
                        voiceParts[index].name = this.textContent.trim();
                    });
                    
                    const fileInfo = document.createElement('div');
                    fileInfo.className = 'file-info';
                    fileInfo.textContent = `(${formatFileSize(part.file.size)})`;
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.textContent = '×';
                    deleteBtn.title = 'Remove this voice part';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        voiceParts.splice(index, 1);
                        updateVoicePartsList();
                    };
                    
                    listItem.appendChild(handle);
                    listItem.appendChild(nameInput);
                    listItem.appendChild(fileInfo);
                    listItem.appendChild(deleteBtn);
                    voicePartsList.appendChild(listItem);
                    
                    // Set up drag events
                    listItem.addEventListener('dragstart', handleDragStart);
                    listItem.addEventListener('dragover', handleDragOver);
                    listItem.addEventListener('dragenter', handleDragEnter);
                    listItem.addEventListener('dragleave', handleDragLeave);
                    listItem.addEventListener('drop', handleDrop);
                    listItem.addEventListener('dragend', handleDragEnd);
                });
            }
            
            // Drag and drop for list reordering
            let dragSourceIndex = null;
            
            function handleDragStart(e) {
                this.classList.add('dragging');
                dragSourceIndex = parseInt(this.dataset.index);
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', dragSourceIndex);
            }
            
            function handleDragOver(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                return false;
            }
            
            function handleDragEnter(e) {
                this.classList.add('drag-over');
            }
            
            function handleDragLeave(e) {
                this.classList.remove('drag-over');
            }
            
            function handleDrop(e) {
                e.stopPropagation();
                e.preventDefault();
                
                this.classList.remove('drag-over');
                
                const targetIndex = parseInt(this.dataset.index);
                if (dragSourceIndex !== null && dragSourceIndex !== targetIndex) {
                    const itemToMove = voiceParts[dragSourceIndex];
                    voiceParts.splice(dragSourceIndex, 1);
                    voiceParts.splice(targetIndex, 0, itemToMove);
                    updateVoicePartsList();
                }
                
                return false;
            }
            
            function handleDragEnd(e) {
                document.querySelectorAll('.voice-part').forEach(item => {
                    item.classList.remove('dragging');
                    item.classList.remove('drag-over');
                });
            }
            
            // File drop zone event handlers
            dropZone.addEventListener('click', function() {
                fileInput.click();
            });
            
            fileInput.addEventListener('change', function() {
                handleFiles(this.files);
                this.value = ''; // Reset to allow selecting the same files again
            });
            
            dropZone.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.classList.add('active');
            });
            
            dropZone.addEventListener('dragleave', function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.classList.remove('active');
            });
            
            dropZone.addEventListener('drop', function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.classList.remove('active');
                
                const files = e.dataTransfer.files;
                handleFiles(files);
            });
            
            // Generate FFmpeg command and process files
            convertButton.addEventListener('click', async function() {
                if (voiceParts.length === 0) {
                    alert('Please add voice parts first.');
                    return;
                }

                loadingOverlay.style.display = 'flex';
                loadingText.textContent = 'Processing audio files...';

                try {
                    ffmpeg = await initFFmpeg(loadingText);
                    
                    // Write input files to FFmpeg virtual filesystem
                    for (let i = 0; i < voiceParts.length; i++) {
                        const part = voiceParts[i];
                        const data = await part.file.arrayBuffer();
                        console.log(`Writing file: input${i}.wav (${part.file.size} bytes)`);
                        ffmpeg.FS.writeFile(`input${i}.wav`, new Uint8Array(data));
                    }

                    // Build command array
                    const args = [
                        //'-y'       // Overwrite output if exists
                    ];
                    
                    // Add input files
                    voiceParts.forEach((_, i) => {
                        args.push('-i', `input${i}.wav`);
                    });

                    // Add filter_complex for merging
                    const filterComplex = voiceParts.map((_, i) => `[${i}:a]`).join('') + 
                                       `amerge=inputs=${voiceParts.length}[aout]`;
                    args.push('-filter_complex', filterComplex);
                    args.push('-map', '[aout]');
                    args.push('-c:a', 'libopus');
                    
                    // Calculate bitrate based on number of parts and user input
                    const bitratePerPart = Math.max(16, Math.min(512, parseInt(bitratePerPartInput.value) || 48));
                    const totalBitrate = voiceParts.length * bitratePerPart;
                    args.push('-b:a', `${totalBitrate}k`);
                    
                    args.push('-mapping_family', '255');
                    
                    const songTitle = songTitleInput.value.trim() || "Choir Recording";
                    args.push('-metadata', `title=${songTitle}`);
                    
                    // Add channel metadata (old style)
                    const channelOrder = voiceParts.map(part => part.name).join(', ');
                    args.push('-metadata', `comment=Channel order: ${channelOrder}`);
                   
                    // TODO: this is the new metadata format
                    // voiceParts.forEach((part, i) => {
                    //     args.push('-metadata', `CHANNEL_${i+1}=${part.name}`);
                    // });

                    args.push('output.opus');

                    console.log('Running FFmpeg command:', args.join(' '));

                    ffmpeg.onExit = result => {

                        if (result !== 0) {
                            throw new Error(`FFmpeg command failed with code ${result}`);
                        }
                        console.log('FFmpeg processing completed successfully.');

                        console.log('Reading output file...');
                        // Read the output file
                        const data = ffmpeg.FS.readFile('output.opus');
                        
                        // Create download link
                        const blob = new Blob([data.buffer], { type: 'audio/opus' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${songTitle}.opus`;
                        a.click();
                        URL.revokeObjectURL(url);

                        // Cleanup files
                        // voiceParts.forEach((_, i) => {
                        //     ffmpeg.FS.unlink(`input${i}.wav`);
                        // });
                        // ffmpeg.FS.unlink('output.opus');
                        
                        loadingOverlay.style.display = 'none';
                    };

                    ffmpeg.callMain(args);
                    
                    // ffmpeg calls onExit when
                    
                } catch (error) {
                    console.error('FFmpeg processing error:', error);
                    loadingText.textContent = 'Error processing files: ' + error.message;
                    loadingOverlay.style.display = 'none';
                }
            });
            
            // Helper function to format file size
            function formatFileSize(bytes) {
                if (bytes < 1024) return bytes + ' B';
                else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
                else return (bytes / 1048576).toFixed(1) + ' MB';
            }
        });
    </script>
</body>
</html>
